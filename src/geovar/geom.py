import numpy as np
from scipy.spatial.transform import Rotation
from rdkit import Chem
try:
    from rdkit.Chem import rdDetermineBonds
except ImportError:
    # rdDetermineBonds was added in 2022.03.1
    raise ImportError("GeoVar requires RDKit >= 2022.03.1")


def read_xyz(filepath):
    """
    Reads an XYZ file.
    Returns:
        atoms: List of element strings ['C', 'H', ...]
        coords: Numpy array of shape (N, 3)
    """
    with open(filepath, 'r') as f:
        lines = f.readlines()
    
    atoms = []
    coords = []
    
    for line in lines[2:]:
        parts = line.split()
        if len(parts) >= 4:
            atoms.append(parts[0])
            coords.append([float(x) for x in parts[1:4]])
            
    return atoms, np.array(coords)


def write_xyz(filepath, atoms, coords, comment="Generated by GeoVar"):
    with open(filepath, 'w') as f:
        f.write(f"{len(atoms)}\n")
        f.write(f"{comment}\n")
        for atom, coord in zip(atoms, coords):
            f.write(f"{atom:2s} {coord[0]:12.6f} {coord[1]:12.6f} {coord[2]:12.6f}\n")


def xyz_to_rdkit(atoms, coords, charge=0, allow_charged_fragments=True):
    """
    Converts raw XYZ data to an RDKit Mol object with bonds inferred.
    Tries multiple strategies to handle tricky geometries (e.g. hypervalency, charge mismatches).
    """
    def _attempt(allow_charged, cov_factor, use_vdw):
        mol = Chem.RWMol()
        conf = Chem.Conformer(len(atoms))
        for i, symbol in enumerate(atoms):
            mol.AddAtom(Chem.Atom(symbol))
            # RDKit expects Point3D
            conf.SetAtomPosition(i, (float(coords[i][0]), float(coords[i][1]), float(coords[i][2])))
        mol.AddConformer(conf)
        
        # Determine Connectivity
        # useVdw=True makes covFactor effective for tuning thresholds
        rdDetermineBonds.DetermineConnectivity(mol, covFactor=cov_factor, useVdw=use_vdw)
        
        # Determine Bond Orders
        rdDetermineBonds.DetermineBondOrders(mol, charge=charge, allowChargedFragments=allow_charged)
        return mol

    # Strategy:
    # 1. Standard (cov=1.3, vdw=False) + user AC
    # 2. Standard (cov=1.3, vdw=False) + flipped AC
    # 3. Standard VdW (cov=1.3, vdw=True) 
    # 4. Stricter VdW (cov=1.2, 1.1, 1.0) to fix "Valence > 4"
    
    strategies = [
        # Standard Connect-the-Dots
        (allow_charged_fragments, 1.3, False),
        (not allow_charged_fragments, 1.3, False),
        
        # Standard VdW
        (allow_charged_fragments, 1.3, True),
        (not allow_charged_fragments, 1.3, True),
        
        # Stricter VdW (Effective for hypervalency)
        (allow_charged_fragments, 1.2, True),
        (not allow_charged_fragments, 1.2, True),
        
        (allow_charged_fragments, 1.1, True),
        (not allow_charged_fragments, 1.1, True),
        
        (allow_charged_fragments, 1.05, True),
        (not allow_charged_fragments, 1.05, True),

        (allow_charged_fragments, 1.0, True),
        (not allow_charged_fragments, 1.0, True),
    ]

    last_error = None
    for ac, cov, vdw in strategies:
        try:
            return _attempt(ac, cov, vdw)
        except Exception as e:
            last_error = e
            continue
            
    raise ValueError(f"RDKit DetermineBondOrders failed for all strategies (charge={charge}): {last_error}")



def identify_active_indices(atoms, r_coords, p_coords, charge=0, allow_charged_fragments=True):
    """
    Identifies the 'Active Set' using RDKit bond detection.
    
    Returns:
        active_indices: Set of integers (indices of atoms moving)
        spectator_indices: Set of integers (indices of atoms frozen)
    """
    # 1. Build RDKit Mols
    mol_r = xyz_to_rdkit(atoms, r_coords, charge=charge, allow_charged_fragments=allow_charged_fragments)
    mol_p = xyz_to_rdkit(atoms, p_coords, charge=charge, allow_charged_fragments=allow_charged_fragments)
    
    active_core = set()
    
    # 2. Iterate over all possible pairs to check for bond changes
    # Since we need to check if a bond exists in one but not the other,
    # OR if the bond type changed (Single -> Double).
    
    num_atoms = len(atoms)
    
    # Helper to get bond type (returns None if no bond)
    def get_bond_order(mol, i, j):
        bond = mol.GetBondBetweenAtoms(i, j)
        if bond is None:
            return 0  # No bond
        return bond.GetBondTypeAsDouble() # e.g. 1.0, 1.5, 2.0
    
    for i in range(num_atoms):
        for j in range(i + 1, num_atoms):
            bo_r = get_bond_order(mol_r, i, j)
            bo_p = get_bond_order(mol_p, i, j)
            
            # If Bond Order changed (including 0 -> 1 or 1 -> 2)
            if abs(bo_r - bo_p) > 0.1:
                active_core.add(i)
                active_core.add(j)
                
    # 3. Add Shell 1 (Neighbors)
    # RDKit makes neighbor lookup easy
    active_shell = set()
    
    def add_neighbors(mol, idx_set, target_set):
        for idx in idx_set:
            atom = mol.GetAtomWithIdx(idx)
            for neighbor in atom.GetNeighbors():
                target_set.add(neighbor.GetIdx())

    # Add neighbors from Reactant context
    add_neighbors(mol_r, active_core, active_shell)
    # Add neighbors from Product context
    add_neighbors(mol_p, active_core, active_shell)
            
    # Combine
    full_active_set = active_core.union(active_shell)
    
    all_indices = set(range(num_atoms))
    spectator_indices = all_indices - full_active_set
    
    return full_active_set, spectator_indices


def align_product_to_reactant(r_coords, p_coords, spectator_indices):
    """
    Rotates and translates Product (P) to match Reactant (R).
    Uses weighted Kabsch alignment: Spectators (wt=100), Active (wt=1).
    This handles cases where spectators < 3 (under-determined rotation) 
    by using active atoms to resolve the ambiguity.
    """
    num_atoms = len(r_coords)
    weights = np.ones(num_atoms)
    
    if spectator_indices:
        # Give high weight to spectators
        weights[list(spectator_indices)] = 100.0
    
    # Weighted Centroids
    w_sum = np.sum(weights)
    centroid_r = np.sum(r_coords * weights[:, np.newaxis], axis=0) / w_sum
    centroid_p = np.sum(p_coords * weights[:, np.newaxis], axis=0) / w_sum
    
    # Center vectors
    W = r_coords - centroid_r
    V = p_coords - centroid_p
    
    try:
        rotation, rmsd = Rotation.align_vectors(W, V, weights=weights)
        p_centered = p_coords - centroid_p
        p_rotated = rotation.apply(p_centered)
        p_final = p_rotated + centroid_r
    except ValueError:
        # Fallback to translation only if rotation cannot be determined
        p_final = p_coords - centroid_p + centroid_r
        
    # Post-correction: Ensure spectator centroid aligns exactly
    # (Weighted alignment might shift it slightly to satisfy active atoms)
    if spectator_indices:
        # Re-calculate centroids based on current p_final
        spec_list = list(spectator_indices)
        c_r = np.mean(r_coords[spec_list], axis=0)
        c_p = np.mean(p_final[spec_list], axis=0)
        p_final += (c_r - c_p)
    
    return p_final
