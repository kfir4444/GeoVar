import numpy as np
from scipy.spatial.transform import Rotation
from rdkit import Chem
try:
    from rdkit.Chem import rdDetermineBonds
except ImportError:
    # rdDetermineBonds was added in 2022.03.1
    raise ImportError("GeoVar requires RDKit >= 2022.03.1")


def read_xyz(filepath):
    """
    Reads an XYZ file.
    Returns:
        atoms: List of element strings ['C', 'H', ...]
        coords: Numpy array of shape (N, 3)
    """
    with open(filepath, 'r') as f:
        lines = f.readlines()
    
    num_atoms = int(lines[0].strip())
    atoms = []
    coords = []
    
    for line in lines[2:]:
        parts = line.split()
        if len(parts) >= 4:
            atoms.append(parts[0])
            coords.append([float(x) for x in parts[1:4]])
            
    return atoms, np.array(coords)


def write_xyz(filepath, atoms, coords, comment="Generated by GeoVar"):
    with open(filepath, 'w') as f:
        f.write(f"{len(atoms)}\n")
        f.write(f"{comment}\n")
        for atom, coord in zip(atoms, coords):
            f.write(f"{atom:2s} {coord[0]:12.6f} {coord[1]:12.6f} {coord[2]:12.6f}\n")


def xyz_to_rdkit(atoms, coords):
    """
    Converts raw XYZ data to an RDKit Mol object with bonds inferred.
    """
    mol = Chem.RWMol()
    conf = Chem.Conformer(len(atoms))
    
    # 1. Add Atoms and Coordinates
    for i, symbol in enumerate(atoms):
        mol.AddAtom(Chem.Atom(symbol))
        # RDKit expects Point3D
        conf.SetAtomPosition(i, (float(coords[i][0]), float(coords[i][1]), float(coords[i][2])))
        
    mol.AddConformer(conf)
    
    # 2. Infer Connectivity and Bond Orders from 3D geometry
    # This detects Single vs Double vs Aromatic automatically
    rdDetermineBonds.DetermineConnectivity(mol)
    rdDetermineBonds.DetermineBondOrders(mol)
    
    return mol


def identify_active_indices(atoms, r_coords, p_coords):
    """
    Identifies the 'Active Set' using RDKit bond detection.
    
    Returns:
        active_indices: Set of integers (indices of atoms moving)
        spectator_indices: Set of integers (indices of atoms frozen)
    """
    # 1. Build RDKit Mols
    mol_r = xyz_to_rdkit(atoms, r_coords)
    mol_p = xyz_to_rdkit(atoms, p_coords)
    
    active_core = set()
    
    # 2. Iterate over all possible pairs to check for bond changes
    # Since we need to check if a bond exists in one but not the other,
    # OR if the bond type changed (Single -> Double).
    
    num_atoms = len(atoms)
    
    # Helper to get bond type (returns None if no bond)
    def get_bond_order(mol, i, j):
        bond = mol.GetBondBetweenAtoms(i, j)
        if bond is None:
            return 0  # No bond
        return bond.GetBondTypeAsDouble() # e.g. 1.0, 1.5, 2.0
    
    for i in range(num_atoms):
        for j in range(i + 1, num_atoms):
            bo_r = get_bond_order(mol_r, i, j)
            bo_p = get_bond_order(mol_p, i, j)
            
            # If Bond Order changed (including 0 -> 1 or 1 -> 2)
            if abs(bo_r - bo_p) > 0.1:
                active_core.add(i)
                active_core.add(j)
                
    # 3. Add Shell 1 (Neighbors)
    # RDKit makes neighbor lookup easy
    active_shell = set()
    
    def add_neighbors(mol, idx_set, target_set):
        for idx in idx_set:
            atom = mol.GetAtomWithIdx(idx)
            for neighbor in atom.GetNeighbors():
                target_set.add(neighbor.GetIdx())

    # Add neighbors from Reactant context
    add_neighbors(mol_r, active_core, active_shell)
    # Add neighbors from Product context
    add_neighbors(mol_p, active_core, active_shell)
            
    # Combine
    full_active_set = active_core.union(active_shell)
    
    all_indices = set(range(num_atoms))
    spectator_indices = all_indices - full_active_set
    
    return full_active_set, spectator_indices


def align_product_to_reactant(r_coords, p_coords, spectator_indices):
    """
    Rotates and translates Product (P) to match Reactant (R)
    minimizing RMSD of the SPECTATOR atoms only.
    """
    if not spectator_indices:
        spectator_list = list(range(len(r_coords)))
    else:
        spectator_list = list(spectator_indices)
    
    P_ref = r_coords[spectator_list]
    P_mobile = p_coords[spectator_list]
    
    centroid_ref = np.mean(P_ref, axis=0)
    centroid_mob = np.mean(P_mobile, axis=0)
    
    V = P_mobile - centroid_mob
    W = P_ref - centroid_ref
    
    try:
        rotation, rmsd = Rotation.align_vectors(W, V)
        p_centered = p_coords - centroid_mob
        p_rotated = rotation.apply(p_centered)
        p_final = p_rotated + centroid_ref
    except ValueError:
        # Fallback to translation only if rotation cannot be determined
        # (e.g. only 1 point, or all points are at the same location)
        p_final = p_coords - centroid_mob + centroid_ref
    
    return p_final
